import java.util.List
import java.util.ArrayList
import org.eclipse.xtext.xbase.lib.Functions
import java.util.concurrent.locks.ReentrantLock
import org.eclipse.xtext.xbase.lib.Procedures
import org.eclipse.smarthome.model.script.actions.Timer

//Userinput needed:
val ArrayList<String> SonosPlayer = newArrayList("Livingroom", "Alfresco", "Portable1")
val ArrayList<String> SonosUUID = newArrayList("{{ sonos_ids.livingroom }}", "{{ sonos_ids.alfresco }}", "{{ sonos_ids.portable1 }}")
val List<Integer> DefaultSpeakerVolume = newArrayList(8, 8, 8, 8, 8, 8, 8, 10, 12, 14, 16, 18, 18, 20, 20, 20, 20, 18, 18, 16, 14, 12, 10, 8)
val String DefaultPlayUri = "x-rincon-mp3radio://http://hr-youfm-live.cast.addradio.de/hr/youfm/live/mp3/128/stream.mp3?ar-distributor=f0a1"

//Userinput end, please do not change settings below if you are not sure that you know what you arre doing!

var Boolean firstRun = true
var Boolean MultiroomVolumeServiceRunning = false
var List<Integer> PlayerStatusUpdateState = newArrayList(0)
var List<Integer> MultiroomVolumeOffset =newArrayList(0)
var List<Integer> MultiroomVolumeAvailable = newArrayList(0)
val ReentrantLock PlayerStatusUpdateLock = new ReentrantLock()
val ReentrantLock MultiroomVolumeLock  = new ReentrantLock()
var Timer AutoremoveTimer = null

val Functions$Function1<String, Boolean> prerequiremets= [ s |
	var JobSuccesfull = true
	if(gSonosState.state === NULL) {
		logError("SonosMultiroom.Service", "Please check input items Sonos..._State. The import of the groupitem.state failed.")
		JobSuccesfull = false
		}
	if(gSonosVolume.state === NULL) {
		logError("SonosMultiroom.Service", "Please check input items Sonos..._Volume. The import of the groupitem.state failed.")
		JobSuccesfull = false
		}
	if(gSonosMultiroom.state === NULL) {
		logError("SonosMultiroom.Service", "Please check input items Sonos..._MultiroomVolume. The import of the groupitem.state failed.")
		JobSuccesfull = false
		}
	if(gSonosMultiroomOffset.state === NULL) {
		logError("SonosMultiroom.Service", "Please check input items Sonos..._Offset. The import of the groupitem.state failed.")
		JobSuccesfull = false
		}
	if(JobSuccesfull == false) {
		logError("SonosMultiroom.Service", "Sonos Multiroom stops because not all prerequirements are available.")
		true
		} else {
		false
		}
	]
val Functions$Function1<List<String>, List<Integer>> initMultiroomVolumeAvailable= [ myArray |
	var Number Cursor = 0
	var String Command
	var List<Integer> functionArray = newArrayList(0)logInfo("SonosMultiroom.Service", "Initialise Sonos Multiroom Service")
	while(Cursor < myArray.size()) {
		Command = "Sonos" + myArray.get((Cursor).intValue) + "_MultiroomVolume"
		val ImportMultiroom = gSonosMultiroom.members.findFirst[ i | i.name == Command ]
		if(ImportMultiroom.state == ON) {
		Command = "Sonos" + myArray.get((Cursor).intValue) + "_Volume"
			val ImportVolume = gSonosVolume.members.findFirst[ i | i.name == Command ]
			functionArray.add(((Cursor).intValue), (Integer::parseInt(ImportVolume.state.toString)))
			} else {
			logInfo("SonosMultiroom.Service", "Multiroom Volume is inactive in Zone " + myArray.get(Cursor.intValue) + ".")
			functionArray.add(((Cursor).intValue), -1)
			}
		Cursor = Cursor+1
		}
	functionArray
	]

val Functions$Function1<List<String>, List<Integer>> initMultiroomVolumeOffset= [ myArray |
	var Number Cursor = 0
	var String Command
	var List<Integer> functionArray = newArrayList(0)
	while(Cursor < myArray.size()) {
		Command = "Sonos" + myArray.get((Cursor).intValue) + "_Offset"
		val ImportOffset = gSonosMultiroomOffset.members.findFirst[ i | i.name == Command ]
		functionArray.add(((Cursor).intValue), (Integer::parseInt(ImportOffset.state.toString)))
		Cursor = Cursor+1
		}
	functionArray
	]

val Functions$Function1<List<String>, List<Integer>> initPlayerStatusUpdateState= [ myArray |
	var Number Cursor = 0
	var String Command
	var List<Integer> functionArray = newArrayList(0)
	logInfo("SonosMultiroom.Service", "Initialise Sonos Player Update Service")
	while(Cursor < myArray.size()) {
		Command = "Sonos" + myArray.get((Cursor).intValue) + "_Control"
		val ImportControl = gSonos.members.findFirst[ i | i.name == Command ]
		if(ImportControl.state == PLAY) {
			functionArray.add((Cursor.intValue), 0)
			}
		if(ImportControl.state != PLAY) {
			functionArray.add((Cursor.intValue), -1)
			}
		Cursor = Cursor +1
		}
	functionArray
	]

val Functions$Function2<List<String>, String, Number> getPlayerID= [ myArray, player |
	var Number Cursor = 0
	var Number Pointer
	while(Cursor < myArray.size()) {
		if(player == myArray.get(Cursor.intValue)) {
			Pointer = Cursor
			Cursor = myArray.size()
			}
		Cursor = Cursor +1
		}
	Pointer
	]

val Functions$Function2<List<String>, String, Number> findCommand= [ myArray, command |
	var Number Cursor = 0
	var Boolean Commandfound = false
	while(Cursor < myArray.size()) {
		if(command == myArray.get(Cursor.intValue)) {
			Commandfound = true
			Cursor = myArray.size()
			}
		Cursor = Cursor +1
		}
	Commandfound
	]

val Procedures.Procedure2<String, String> setUpdate = [myItem, myCommand |
	var String Device
	Device = "Sonos" + myItem
	Device.sendCommand(myCommand)
	]


rule "Sonos Multiroom"
when
Item SonosMultiroom received command
then
logInfo("SonosMultiroom.Service", "Multiroom control active")

var ArrayList<String> SonosCoordinatorList = newArrayList("empty")
var List<String> SonosControl
var List<String> SonosMode
var String SonosCommand
var Boolean AutoremoveServiceRunning = false
var Boolean JobSuccesfull = false
var Boolean MultiroomForced = false
var Boolean ResetCursor = false
var Number CursorPointer
var Number Cursor
var Number SonosControlCursor
var Number SonosModeCursor

JobSuccesfull = prerequiremets.apply("run")

if(MultiroomVolumeAvailable.size() < SonosPlayer.size()) {
	MultiroomVolumeAvailable = initMultiroomVolumeAvailable.apply(SonosPlayer)
	}

if(MultiroomVolumeOffset.size() < SonosPlayer.size()) {
	MultiroomVolumeOffset = initMultiroomVolumeOffset.apply(SonosPlayer)
	}

if(PlayerStatusUpdateState.size() < SonosPlayer.size()) {
	PlayerStatusUpdateState = initPlayerStatusUpdateState.apply(SonosPlayer)
	}

if(PlayerStatusUpdateLock.isLocked) {
	AutoremoveServiceRunning = true
	}

Cursor = 0
while(Cursor < SonosPlayer.size()) {
	SonosCommand = "Sonos" + SonosPlayer.get((Cursor).intValue) + "_Coordinator"
	val ImportCoordinator = gSonos.members.findFirst[ i | i.name == SonosCommand ]
	SonosCoordinatorList.add(((Cursor).intValue), ImportCoordinator.state)
	Cursor = Cursor+1
	}
Cursor = 0
if(Cursor == 0) {
	val List<String> ReadCommands = SonosMultiroom.state.toString.split("/Devices=")
	SonosControl=ReadCommands.get(1).split("/")
	SonosMode=ReadCommands.get(0).split("/")
	}

SonosModeCursor = 0
while(SonosModeCursor < SonosMode.size()) {

	//DefaultVolume Start
	if(SonosMode.get((SonosModeCursor).intValue) == "DefaultVolume") {
		var Number SetVolume
		var Number ZoneOffset
		SetVolume = DefaultSpeakerVolume.get(now.getHourOfDay)
		SonosControlCursor = 0
		JobSuccesfull = findCommand.apply(SonosMode, "MultiroomTarget")
		if(JobSuccesfull == true) {
			SonosControlCursor = 1
			}
		if(MultiroomVolumeLock.isLocked){
			//Warte eine Sekunde falls MultiroomVolume derzeit aktiv ist
			Thread::sleep(500)
			}
		logInfo("SonosMultiroom.Service", "MultiroomVolume Service locked.")
		MultiroomVolumeLock.lock()
		try {
			MultiroomVolumeServiceRunning = true
			if(MultiroomForced == false) {
				while(SonosControlCursor < SonosControl.size()) {
					Cursor = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
					if(MultiroomVolumeAvailable.get((Cursor).intValue) == -1) {
						logWarn("SonosMultiroom.Service", "MultiroomVolume für die Zone " + SonosPlayer.get(Cursor.intValue) + " ist deaktiviet, der Befehl wird ignoriert.")
						} else {
						ZoneOffset = ((SetVolume/100)*MultiroomVolumeOffset.get((Cursor).intValue)).intValue
						if(MultiroomVolumeAvailable.get((Cursor).intValue) != ZoneOffset){
							MultiroomVolumeAvailable.set(((Cursor).intValue), ZoneOffset)
							SonosCommand = ZoneOffset.toString
							logInfo("SonosMultiroom.Service", "DefaultVolume will be applied for Zone " + SonosControl.get((SonosControlCursor).intValue) + ".")
							setUpdate.apply(SonosControl.get(SonosControlCursor.intValue) + "_Volume", SonosCommand)
							}
						}
					SonosControlCursor = SonosControlCursor+1
					}
				}
			if(MultiroomForced == true) {
				Cursor = 0
				while(Cursor < SonosPlayer.size()) {
					if(MultiroomVolumeAvailable.get((Cursor).intValue) == -2) {
						ZoneOffset = ((SetVolume/100)*MultiroomVolumeOffset.get((Cursor).intValue)).intValue
						if(MultiroomVolumeAvailable.get((Cursor).intValue) != ZoneOffset) {
							MultiroomVolumeAvailable.set(((Cursor).intValue), ZoneOffset)
							SonosCommand = ZoneOffset.toString
							logInfo("SonosMultiroom.Service", "DefaultVolume will be applied for Zone " + SonosPlayer.get((Cursor).intValue) + ". ")
							setUpdate.apply(SonosPlayer.get(Cursor.intValue) + "_Volume", SonosCommand)
							}
						}
					Cursor = Cursor+1
					}
				}
			}
		finally{
			MultiroomVolumeLock.unlock()
			}
		}
	//DefaultVolume Ende


	//MultiroomVolume Start
	if(SonosMode.get((SonosModeCursor).intValue) == "MultiroomVolume") {
		SonosControlCursor = 0
		JobSuccesfull = findCommand.apply(SonosMode, "MultiroomTarget")
		if(JobSuccesfull == true) {
			SonosControlCursor = 1
			}
		JobSuccesfull = false
		if(MultiroomVolumeLock.isLocked){
			Thread::sleep(500)
			}
		logInfo("SonosMultiroom.Service", "MultiroomVolume Service locked.")
		MultiroomVolumeLock.lock()
		try {
			MultiroomVolumeServiceRunning = true
			var Number ZoneCoordinatorOffset
			var Number ZonePlayerOffset
			while(SonosControlCursor < SonosControl.size()) {
				CursorPointer = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
				if(MultiroomVolumeAvailable.get((CursorPointer).intValue) < 0) {
					logWarn("SonosMultiroom.Service", "MultiroomVolume für die Zone " + SonosPlayer.get(CursorPointer.intValue) + " ist deaktiviet, der Befehl wird ignoriert.")
					}
				ZonePlayerOffset = MultiroomVolumeOffset.get((CursorPointer).intValue)
				Cursor = 0
				var Number MultiroomCursorPointer
				while(Cursor < SonosPlayer.size()) {
					if(SonosCoordinatorList.get((CursorPointer).intValue) == SonosUUID.get((Cursor).intValue) && SonosPlayer.get(Cursor.intValue) != SonosControl.get(SonosControlCursor.intValue)) {
						if(MultiroomVolumeAvailable.get((Cursor).intValue) >= 0) {
							MultiroomCursorPointer = Cursor
							ZoneCoordinatorOffset = MultiroomVolumeOffset.get((Cursor).intValue)
							JobSuccesfull = true
							Cursor = SonosPlayer.size()
							}
						}
					Cursor = Cursor+1
					}
				if(JobSuccesfull == true) {
					var Number mvolume
					mvolume= MultiroomVolumeAvailable.get((MultiroomCursorPointer).intValue)
					mvolume = ((mvolume/ZoneCoordinatorOffset)*ZonePlayerOffset).intValue
					if(mvolume != MultiroomVolumeAvailable.get((CursorPointer).intValue) && MultiroomVolumeAvailable.get(CursorPointer.intValue) != -1) {
						SonosCommand = mvolume.toString
						logInfo("SonosMultiroom.Service", "MultiroomVolume sets volume of current zone player " + SonosControl.get((SonosControlCursor).intValue) + " equal to zone coordinator volume.")
						setUpdate.apply(SonosControl.get(SonosControlCursor.intValue) + "_Volume", SonosCommand)
						}
					}
				if(JobSuccesfull == false) {
					if(MultiroomVolumeAvailable.get(CursorPointer.intValue) != -1) {
						logInfo("SonosMultiroom.Service", "Multiroom Volume will switch to DefaultVolume, there is no player with active MultiroomVolume to set volume available.")
						SonosMode.set(((SonosModeCursor).intValue), "DefaultVolume")
						MultiroomVolumeAvailable.set((CursorPointer.intValue), -2)
						MultiroomForced = true
						ResetCursor = true
						}
					}
				JobSuccesfull = false
				SonosControlCursor = SonosControlCursor+1
				}
			}
		finally{
			MultiroomVolumeLock.unlock()
			}
		}
	//MultiroomVolume Ende


	//DisableMultiroomVolume Start
	if(SonosMode.get((SonosModeCursor).intValue)=="DisableMultiroomVolume"){
		SonosControlCursor = 0
		while(SonosControlCursor < SonosControl.size()) {
			Cursor = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			if(MultiroomVolumeAvailable.get(Cursor.intValue) != -1) {
				logInfo("SonosMultiroom.Service", "MultiroomVolume will be disabled for Zone " + SonosPlayer.get(Cursor.intValue) + ".")
				MultiroomVolumeAvailable.set((Cursor.intValue), -1)
				}
			SonosControlCursor = SonosControlCursor + 1
			}
		}
	//DisableMultiroomVolume Ende

	//EnableMultiroomVolume Start
	if(SonosMode.get((SonosModeCursor).intValue)=="EnableMultiroomVolume"){
		SonosControlCursor = 0
		while(SonosControlCursor < SonosControl.size()) {
			Cursor = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			if(MultiroomVolumeAvailable.get(Cursor.intValue) == -1) {
				logInfo("SonosMultiroom.Service", "MultiroomVolume will be enabled for Zone " + SonosPlayer.get(Cursor.intValue) + ".")
				SonosCommand = "Sonos" + SonosPlayer.get((Cursor).intValue) + "_Volume"
				val ImportVolume = gSonosVolume.members.findFirst[ i | i.name == SonosCommand ]
				MultiroomVolumeAvailable.set((Cursor.intValue), (Integer::parseInt(ImportVolume.state)))
				}
			SonosControlCursor = SonosControlCursor + 1
			}
		}
	//EnableMultiroomVolume Ende


	//Standalone Start
	if(SonosMode.get((SonosModeCursor).intValue)=="Standalone"){
		SonosControlCursor = 0
		while(SonosControlCursor < SonosControl.size()) {
			CursorPointer = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			Cursor = 0
			while(Cursor < SonosPlayer.size()) {
				if(SonosCoordinatorList.get((Cursor).intValue) == SonosCoordinatorList.get((CursorPointer).intValue) && CursorPointer != Cursor) {
					logInfo("SonosMultiroom.Service", "Standalone removes the Zoneplayer " + SonosPlayer.get((Cursor).intValue) +".")
					SonosCommand = SonosUUID.get((Cursor).intValue)
					setUpdate.apply(SonosControl.get(SonosControlCursor) + "_Remove", SonosCommand)
					SonosCoordinatorList.set(((Cursor).intValue), SonosUUID.get((Cursor).intValue))
					}
				Cursor = Cursor+1
				}
			SonosControlCursor = SonosControlCursor+1
			}
		}
	//Standalone Ende


	//MultiroomTarget Start:
	if(SonosMode.get((SonosModeCursor).intValue)=="MultiroomTarget"){
		CursorPointer = getPlayerID.apply(SonosPlayer, SonosControl.get(0))
		Cursor = 0
		SonosControlCursor = 0
		JobSuccesfull = false
		while(SonosControlCursor < SonosControl.size()) {
			Cursor = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			if(SonosControl.get(SonosControlCursor.intValue) != SonosPlayer.get(Cursor.intValue)) {
				logInfo("SonosMultiroom.Service", "MultiroomTarget add Zoneplayer " + SonosPlayer.get((Cursor).intValue) + " to Zone " + SonosControl.get(0) + ".")
				SonosCoordinatorList.set(((Cursor).intValue), SonosCoordinatorList.get((CursorPointer).intValue))
				setUpdate.apply(SonosControl.get(0) + "_Add", SonosUUID.get(Cursor.intValue))
				}
			SonosControlCursor = SonosControlCursor+1
			}
		}
	//MultiroomTarget Ende


//Multiroom Start
	if(SonosMode.get((SonosModeCursor).intValue) == "Multiroom") {
		var Boolean	UseActivePlayers = false
		JobSuccesfull = findCommand.apply(SonosMode, "UseActivePlayer")
		if(JobSuccesfull == true) {
			logInfo("SonosMultiroom.Service", "Multiroom will modify active players if needed, because the option UseActivePlayer is used.")
			UseActivePlayers = true
			}
		SonosControlCursor = 0
		JobSuccesfull = false
		var Boolean SpeakerActive
		while(SonosControlCursor < SonosControl.size()) {
			SpeakerActive = false
			CursorPointer = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			if(PlayerStatusUpdateState.get(CursorPointer.intValue) == 0 && UseActivePlayers == false) {
				SpeakerActive = true
				}
			if(SpeakerActive == false) {
				Cursor = 0
				while(Cursor < SonosPlayer.size()) {
					if(PlayerStatusUpdateState.get(Cursor.intValue) == 0 && SonosPlayer.get((Cursor).intValue) != SonosControl.get((SonosControlCursor).intValue)) {
						var Number MultiroomCursor = getPlayerID.apply(SonosUUID, SonosCoordinatorList.get(Cursor.intValue))
						JobSuccesfull = true
						logInfo("SonosMultiroom.Service", "Multiroom add " + SonosPlayer.get((CursorPointer).intValue) + " to Zone " + SonosPlayer.get((Cursor).intValue) + ".")
						SonosCoordinatorList.set(((CursorPointer).intValue), SonosUUID.get((MultiroomCursor).intValue))
						setUpdate.apply(SonosPlayer.get((MultiroomCursor).intValue) +"_Add", SonosUUID.get((CursorPointer).intValue))
						Cursor = SonosPlayer.size()
						}
					Cursor = Cursor+1
					}
				}
			SonosControlCursor = SonosControlCursor+1
			}
		if(JobSuccesfull == false  && SpeakerActive == false) {
			logInfo("SonosMultiroom.Service", "Multiroom will change to Play, because there is no active Zone available.")
			SonosMode.set(((SonosModeCursor).intValue), "Play")
			MultiroomForced = true
			ResetCursor = true
			}
		}
	//Multiroom Ende


	//Play Start
	if(SonosMode.get((SonosModeCursor).intValue) == "Play") {
		JobSuccesfull = false
		logInfo("SonosMultiroom.Service", "Play will play the Default URI in Zone " + SonosControl.get(0) + ".")
		setUpdate.apply(SonosControl.get(0) + "_PlayURI", DefaultPlayUri)
		JobSuccesfull = true
		ResetCursor = false
		JobSuccesfull = findCommand.apply(SonosMode, "MultiroomTarget")
		if(JobSuccesfull == true) {
			SonosMode.set(((SonosModeCursor).intValue), "MultiroomVolume")
			MultiroomForced = true
			ResetCursor = true
			}
		}
	//Play Ende


	//Remove Start
	if(SonosMode.get((SonosModeCursor).intValue)=="Remove") {
		SonosControlCursor = 0
		JobSuccesfull = true
		while(SonosControlCursor < SonosControl.size()) {
			CursorPointer = getPlayerID.apply(SonosPlayer, SonosControl.get(SonosControlCursor.intValue))
			Cursor = getPlayerID.apply(SonosUUID, SonosCoordinatorList.get(CursorPointer.intValue))
			if(Cursor == CursorPointer) {
				SonosCommand = "ON"
				logInfo("SonosMultiroom.Service", "Remove Zoneplayer " + SonosControl.get((SonosControlCursor).intValue) + ".")
				setUpdate.apply(SonosControl.get((SonosControlCursor).intValue) + "_StandAlone", SonosCommand)
				SonosCoordinatorList.set(((Cursor).intValue), SonosUUID.get((Cursor).intValue))
				} else{
				SonosCommand = SonosUUID.get((CursorPointer).intValue)
				logInfo("SonosMultiroom.Service", "Remove Zoneplayer " + SonosPlayer.get((CursorPointer).intValue) + ".")
				setUpdate.apply(SonosPlayer.get((Cursor).intValue) + "_Remove", SonosCommand)
				SonosCoordinatorList.set(((Cursor).intValue), SonosUUID.get((Cursor).intValue))
				}
			SonosControlCursor = SonosControlCursor+1
			}
		}
		//Remove Ende
	if(ResetCursor == true ) {
		SonosModeCursor = SonosModeCursor-1
		ResetCursor = false
		}
	SonosModeCursor = SonosModeCursor+1
	}
if(AutoremoveServiceRunning == true) {
	if(PlayerStatusUpdateLock.isLocked) {
		Thread::sleep(2000)
		if(PlayerStatusUpdateLock.isLocked) {
			PlayerStatusUpdateLock.unlock()
			}
		}
	}
if(MultiroomVolumeServiceRunning == true) {
	MultiroomVolumeServiceRunning = false
	if(MultiroomVolumeLock.isLocked()) {
		MultiroomVolume.unlock()
		}
	logInfo("SonosMultiroom.Service", "MultiroomVolume Service unlocked.")
	Cursor = 0
	logInfo("SonosMultiroom.Service", "MultiroomVolume Service refreshes the volume index.")
	while(Cursor < SonosPlayer.size()) {
		if(MultiroomVolumeAvailable.get(Cursor.intValue) != -1) {
			SonosCommand = "Sonos" + SonosPlayer.get((Cursor).intValue) + "_Volume"
			val ImportVolume = gSonosVolume.members.findFirst[ i | i.name == SonosCommand ]
			MultiroomVolumeAvailable.set(((Cursor).intValue), (Integer::parseInt(ImportVolume.state.toString)))
			}
		Cursor = Cursor+1
		}
	}
logInfo("SonosMultiroom.Service", "Multiroom Service inactiv.")
end

rule "Sonos Multiroom Volume Service"
when
Item gSonosVolume changed
then
if(!MultiroomVolumeLock.isLocked && MultiroomVolumeServiceRunning == false){
	logInfo("SonosMultiroom.Service", "MultiroomVolume Service locked.")
	MultiroomVolumeServiceRunning = true
	MultiroomVolumeLock.lock()
	try {
		Thread::sleep(1000)
		var ArrayList<String> MultiroomVolumeCoordinatorList = newArrayList("empty")
		var List<Integer> MultiroomVolumeCurrentVolume = newArrayList(0)
		var Number VolumeCursor = 0
		var Number VolumeCursor2 = 0
		var String MultiroomVolumeCommand
		var Boolean JobSuccesfull = prerequiremets.apply("run")
		if(JobSuccesfull == false) {
			if(MultiroomVolumeAvailable.size() < SonosPlayer.size()) {
				MultiroomVolumeAvailable = initMultiroomVolumeAvailable.apply(SonosPlayer)
				}
			if(MultiroomVolumeOffset.size() < SonosPlayer.size()) {
				MultiroomVolumeOffset = initMultiroomVolumeOffset.apply(SonosPlayer)
				}
			VolumeCursor = 0
			while(VolumeCursor < SonosPlayer.size()) {
				MultiroomVolumeCommand = "Sonos" + SonosPlayer.get((VolumeCursor).intValue) + "_Coordinator"
				val ImportCoordinator = gSonos.members.findFirst[ i | i.name == MultiroomVolumeCommand ]
				MultiroomVolumeCoordinatorList.add(((VolumeCursor).intValue), ImportCoordinator.state)
				MultiroomVolumeCommand = "Sonos" + SonosPlayer.get((VolumeCursor).intValue) + "_Volume"
				val ImportVolume = gSonosVolume.members.findFirst[ i | i.name == MultiroomVolumeCommand ]
				MultiroomVolumeCurrentVolume.add(((VolumeCursor).intValue), (Integer::parseInt(ImportVolume.state.toString)))
				VolumeCursor = VolumeCursor+1
				}
			VolumeCursor = 0
			while(VolumeCursor < SonosPlayer.size()) {
				if(MultiroomVolumeCurrentVolume.get((VolumeCursor).intValue) != MultiroomVolumeAvailable.get((VolumeCursor).intValue)) {
					if(MultiroomVolumeAvailable.get((VolumeCursor).intValue) >= 0) {
						VolumeCursor2 = 0
						while(VolumeCursor2 < SonosPlayer.size()) {
							if(MultiroomVolumeCoordinatorList.get((VolumeCursor).intValue) == MultiroomVolumeCoordinatorList.get((VolumeCursor2).intValue)) {
								if(MultiroomVolumeAvailable.get((VolumeCursor).intValue) >= 0) {
									var Number MultiroomVolumeSetVolume
									MultiroomVolumeSetVolume = (((MultiroomVolumeCurrentVolume.get((VolumeCursor).intValue)/MultiroomVolumeOffset.get((VolumeCursor).intValue))*MultiroomVolumeOffset.get((VolumeCursor2).intValue)).intValue)
									MultiroomVolumeCommand = (MultiroomVolumeSetVolume).toString
									if(MultiroomVolumeSetVolume != MultiroomVolumeCurrentVolume.get((VolumeCursor2).intValue)) {
										logInfo("SonosMultiroom.Service", "MultiroomVolume Service changes the volume of Zone " + SonosPlayer.get((VolumeCursor2).intValue) + ", because Zone " + SonosPlayer.get((VolumeCursor).intValue) + " changed volume.")
										setUpdate.apply(SonosPlayer.get((VolumeCursor2).intValue) + "_Volume", MultiroomVolumeCommand)
										MultiroomVolumeCurrentVolume.set(((VolumeCursor2).intValue), (Integer::parseInt(MultiroomVolumeCommand)))
										MultiroomVolumeAvailable.set(((VolumeCursor2).intValue), (Integer::parseInt(MultiroomVolumeCommand)))
										}
									}
								}
							VolumeCursor2 = VolumeCursor2+1
							}
						}
					}
				VolumeCursor = VolumeCursor+1
				}
			}
		Thread::sleep(1000)
		}
	finally{
		MultiroomVolumeLock.unlock()
		MultiroomVolumeServiceRunning = false
		if(!MultiroomVolumeLock.isLocked){
			logInfo("SonosMultiroom.Service", "Multiroom Volume Service unlocked.")
			}
		}
	}
end


rule "Sonos Player Status Update Service"
when
Item gSonosState changed or
Item SonosMultiroomUpdatePlayers received update ON
then
var Boolean AllPlayersOFF = true
if(triggeringItem.name == SonosMultiroomUpdatePlayers) {
	AutoremoveTimer.cancel()
	AutoremoveTimer = null
	}
if(!PlayerStatusUpdateLock.isLocked){
	logInfo("SonosMultiroom.Service", "Player Status Update Service locked.")
	PlayerStatusUpdateLock.lock()
	try {
		//Initialisiere Variablen
		var DateTime PlayerStatusDateTime = now
		var Boolean JobSuccesfull = true
		var Number PlayerStatusCounter
		var String PlayerStatusCommand

		JobSuccesfull = prerequiremets.apply("run")
		if(JobSuccesfull == false) {
			if(PlayerStatusUpdateState.size() < SonosPlayer.size()) {
				PlayerStatusUpdateState = initPlayerStatusUpdateState.apply(SonosPlayer)
				}
			PlayerStatusCounter = 0
			while(PlayerStatusCounter < SonosPlayer.size()) {
				PlayerStatusCommand = "Sonos" + SonosPlayer.get((PlayerStatusCounter).intValue) + "_Control"
				val ImportControl = gSonos.members.findFirst[ i | i.name == PlayerStatusCommand ]
				if(ImportControl.state == PLAY) {
					AllPlayersOFF = false
					PlayerStatusUpdateState.set((PlayerStatusCounter.intValue), 0)
					}
				if(ImportControl.state != PLAY) {
					PlayerStatusCommand = "Sonos" + SonosPlayer.get((PlayerStatusCounter).intValue) + "_Coordinator"
					val ImportCoordinator = gSonos.members.findFirst[ i | i.name == PlayerStatusCommand ]
					if(ImportCoordinator.state == SonosUUID.get(PlayerStatusCounter.intValue)) {
						PlayerStatusUpdateState.set((PlayerStatusCounter.intValue), -1)
						}
					if(ImportCoordinator.state != SonosUUID.get(PlayerStatusCounter.intValue)) {
						if(PlayerStatusUpdateState.get(PlayerStatusCounter.intValue) > 0) {
							if(PlayerStatusUpdateState.get(PlayerStatusCounter.intValue) <= PlayerStatusDateTime.getSecondOfDay || PlayerStatusUpdateState.get(PlayerStatusCounter.intValue) > 86399) {
								var Number PlayerStatusCounter2 = getPlayerID.apply(SonosUUID, ImportCoordinator.state)
								logInfo("SonosMultiroom.Service", "Autoremove removes the inactive Zoneplayer " + SonosPlayer.get((PlayerStatusCounter).intValue) + ".")
								setUpdate.apply(SonosPlayer.get((PlayerStatusCounter2).intValue) + "_Remove", SonosUUID.get(PlayerStatusCounter.intValue))
								PlayerStatusUpdateState.set((PlayerStatusCounter.intValue), -1)
								PlayerStatusCounter2 = SonosPlayer.size()
								}

							}
						else {
							JobSuccesfull = false
							PlayerStatusUpdateState.set((PlayerStatusCounter.intValue), (PlayerStatusDateTime.getSecondOfDay+60))
							}
						}
					}
				PlayerStatusCounter = PlayerStatusCounter+1
				}
			if(AllPlayersOFF == true && JobSuccesfull == true && AutoremoveTimer !== null) {
				AutoremoveTimer.cancel()
				AutoremoveTimer = null
				}
			if(JobSuccesfull  == false && AutoremoveTimer === null) {
				PlayerStatusCounter = 0
				var Number AutoremoveNextTimer
				while(PlayerStatusCounter < SonosPlayer.size()) {
					if(PlayerStatusUpdateState.get(PlayerStatusCounter.intValue) > PlayerStatusDateTime.getSecondOfDay) {
						if(AutoremoveNextTimer === null) {
							AutoremoveNextTimer = PlayerStatusUpdateState.get(PlayerStatusCounter.intValue)
							}
						if(PlayerStatusUpdateState.get(PlayerStatusCounter.intValue) < AutoremoveNextTimer && AutoremoveNextTimer !== null) {
							AutoremoveNextTimer = PlayerStatusUpdateState.get(PlayerStatusCounter.intValue)
							}
						}
					PlayerStatusCounter = PlayerStatusCounter + 1
					}
				if(AutoremoveNextTimer !== null) {
					AutoremoveNextTimer = (AutoremoveNextTimer-PlayerStatusDateTime.getSecondOfDay).intValue
					logInfo("SonosMultiroom.Service", "Player Update Service will refresh in " +  AutoremoveNextTimer + " seconds.")
					AutoremoveTimer = createTimer(now.plusSeconds(AutoremoveNextTimer), [|
						SonosMultiroomUpdatePlayers.postUpdate(ON)
						AutoremoveTimer = null
						])
					}
				}
			}
		}
	finally{
		PlayerStatusUpdateLock.unlock()
		if(!PlayerStatusUpdateLock.isLocked){
			logInfo("SonosMultiroom.Service", "Player Status Update Service unlocked.")
			}
		}
	}
end


rule "Update MultiroomVolume Settings"
when
Item gSonosMultiroom changed
then
var Boolean JobsDone = false
var Number MultiroomStatusCursor
var String MultiroomStatusCommand
JobsDone = prerequiremets.apply("run")
if(JobsDone == false) {
	logInfo("SonosMultiroom.Service", "Refresh Multiroom Volume settings from items.")
	if(MultiroomVolumeAvailable.size() < SonosPlayer.size()) {
		MultiroomVolumeAvailable = initMultiroomVolumeAvailable.apply(SonosPlayer)
		JobsDone = true
		}
	if(JobsDone == false) {
		MultiroomStatusCursor = 0
		while(MultiroomStatusCursor < SonosPlayer.size()) {
			MultiroomStatusCommand = "Sonos" + SonosPlayer.get((MultiroomStatusCursor).intValue) + "_MultiroomVolume"
			val ImportMultiroom = gSonosMultiroom.members.findFirst[ i | i.name == MultiroomStatusCommand ]
			if(ImportMultiroom.state == ON) {
				MultiroomStatusCommand = "Sonos" + SonosPlayer.get((MultiroomStatusCursor).intValue) + "_Volume"
				val ImportVolume = gSonosVolume.members.findFirst[ i | i.name == MultiroomStatusCommand ]
				MultiroomVolumeAvailable.set(((MultiroomStatusCursor).intValue), (Integer::parseInt(ImportVolume.state.toString)))
				} else {
				if(MultiroomVolumeAvailable.get(MultiroomStatusCursor.intValue) != -1) {
					logInfo("SonosMultiroom.Service", "Multiroom Volume is disabled in Zone " + SonosPlayer.get(MultiroomStatusCursor.intValue) + ".")
					MultiroomVolumeAvailable.set(((MultiroomStatusCursor).intValue), -1)
					}
				}
			MultiroomStatusCursor = MultiroomStatusCursor+1
			}
		}
	}
end

rule "Update Multiroom Offset Settings"
when
Item gSonosMultiroomOffset changed
then
var Boolean JobSuccesfull = false
var Number MultiroomOffsetCursor
var String MultiroomOffsetCommand
JobSuccesfull = prerequiremets.apply("run")
if(JobSuccesfull == false) {
	logInfo("SonosMultiroom.Service", "Refresh Multiroom offset settings of items.")
	if(MultiroomVolumeAvailable.size() < SonosPlayer.size()) {
		MultiroomVolumeAvailable = initMultiroomVolumeAvailable.apply(SonosPlayer)
		}
	if(MultiroomVolumeOffset.size() < SonosPlayer.size()) {
		MultiroomVolumeOffset = initMultiroomVolumeOffset.apply(SonosPlayer)
		}
	if(JobSuccesfull == false) {
		if(MultiroomVolumeLock.isLocked) {
			Thread::sleep(1000)
			}
		if(!MultiroomVolumeLock.isLocked) {
			logInfo("SonosMultiroom.Service", "MultiroomVolume Service locked.")
			}
		MultiroomVolumeLock.lock()
		MultiroomVolumeServiceRunning = true
		try {
			MultiroomOffsetCursor = 0
			while(MultiroomOffsetCursor < SonosPlayer.size()) {
				if(MultiroomVolumeAvailable.get(MultiroomOffsetCursor.intValue) != -1) {
					MultiroomOffsetCommand = "Sonos" + SonosPlayer.get((MultiroomOffsetCursor).intValue) + "_Offset"
					val ImportOffset = gSonosMultiroomOffset.members.findFirst[ i | i.name == MultiroomOffsetCommand ]
					if(MultiroomVolumeOffset.get(MultiroomOffsetCursor.intValue) != (Integer::parseInt(ImportOffset.state.toString))) {
						logInfo("SonosMultiroom.Service", "Offset of Zone " + SonosPlayer.get(MultiroomOffsetCursor.intValue) + " will be changed.")
						var Number MultiroomOffsetValue = (MultiroomVolumeAvailable.get(MultiroomOffsetCursor.intValue)/MultiroomVolumeOffset.get(MultiroomOffsetCursor.intValue)*(Integer::parseInt(ImportOffset.state.toString))).intValue
						MultiroomVolumeOffset.set(((MultiroomOffsetCursor).intValue), (Integer::parseInt(ImportOffset.state.toString)))
						MultiroomOffsetCommand = MultiroomOffsetValue.toString
						setUpdate.apply(SonosPlayer.get(MultiroomOffsetCursor.intValue) + "_Volume", MultiroomOffsetCommand)
						MultiroomVolumeAvailable.set(((MultiroomOffsetCursor).intValue), MultiroomOffsetValue)
						}
					}
				MultiroomOffsetCursor = MultiroomOffsetCursor+1
				}
			}
		finally{
			MultiroomVolumeLock.unlock()
			MultiroomVolumeServiceRunning = false
			if(!MultiroomVolumeLock.isLocked){
				logInfo("SonosMultiroom.Service", "Multiroom Volume Service unlocked.")
				}
			}
		}
	}
end
